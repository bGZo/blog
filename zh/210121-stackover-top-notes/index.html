<!doctype html>
<html lang="zh_CN">

<head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.68.3" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Stackover C&#43;&#43; 热门问题 - @bGZoCg">
    <meta name="twitter:description" content="问题皆来源于下面的两个链接1, 本文做了部分的摘录, 感谢翻译：
 https://stackoverflow.com/questions/tagged/c%2b%2b?tab=Votes https://stackoverflow.com/questions/tagged/c?tab=Votes ">
    <meta name="twitter:site" content="http://x.com/">
    <meta name="twitter:creator" content="">
    <meta name="twitter:image" content="https://dandelionfs.oss-cn-beijing.aliyuncs.com/author-heart.webp">
    
    
    <meta property="og:locale" content="zh_CN">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Stackover C&#43;&#43; 热门问题 - @bGZoCg">
    <meta property="og:description" content="问题皆来源于下面的两个链接1, 本文做了部分的摘录, 感谢翻译：
 https://stackoverflow.com/questions/tagged/c%2b%2b?tab=Votes https://stackoverflow.com/questions/tagged/c?tab=Votes ">
    <meta property="og:url" content="http://x.com/zh/210121-stackover-top-notes/">
    <meta property="og:site_name" content="@bGZoCg">
    <meta property="og:image" content="https://dandelionfs.oss-cn-beijing.aliyuncs.com/author-heart.webp">
    
    <title>Stackover C&#43;&#43; 热门问题 - @bGZoCg</title>

    <meta name="author" content="bGZoCg">
    <meta name="description" content="问题皆来源于下面的两个链接1, 本文做了部分的摘录, 感谢翻译：
 https://stackoverflow.com/questions/tagged/c%2b%2b?tab=Votes https://stackoverflow.com/questions/tagged/c?tab=Votes ">

    
    

    
    

    
    
    <link rel="stylesheet" href="/css/theme.css">
    <link rel="stylesheet" href="/css/chroma.dracula.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌈</text></svg>">
</head>
<body class="font-serif bg-gray-200 border-t-4 border-blue-500 antialiased">
    <div class="w-full p-6 md:w-2/3 md:px-0 md:mx-auto xl:w-2/5">
        <header class="mb-6">
            
            <div class="mb-6 md:flex md:items-center">
                
<div>
    <div class="back-button"><a class="text-lg mb-8 inline-block" href="/zh">&larr; 返回</a></div>

    
    
    <h1 class="text-4xl font-bold">Stackover C&#43;&#43; 热门问题</h1>
    <time datetime="2021-01-21 14:31:44 CST">21 Jan 2021</time>
    
    
    
    <ol class="mt-4">
        
        <li class="inline-block">
            <a class="border-none text-gray-800 text-xs bg-gray-400 hover:bg-gray-600 hover:text-white rounded-sm px-3 py-1" href="http://x.com/tags/cpp">Cpp</a>
        </li>
        
    </ol>
    
</div>

            </div>

            
            
        </header>

        
        
<nav id="TableOfContents">
  <ul>
    <li><a href="#questions-问题">QUESTIONS 问题</a></li>
    <li><a href="#link-链接">LINK 链接</a></li>
  </ul>
</nav>
<article class="mb-12">
    <p>问题皆来源于下面的两个链接<sup><a href="#j1">1</a></sup>, 本文做了部分的摘录, 感谢翻译：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/tagged/c%2b%2b?tab=Votes">https://stackoverflow.com/questions/tagged/c%2b%2b?tab=Votes</a></li>
<li><a href="https://stackoverflow.com/questions/tagged/c?tab=Votes">https://stackoverflow.com/questions/tagged/c?tab=Votes</a></li>
</ol>
<h2 id="questions-问题">QUESTIONS 问题</h2>
<ul>
<li>分支预测（Branch Prediction）导致有序数的效率提高.</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="c1">// Generate data
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">arraySize</span> <span class="o">=</span> <span class="n">32768</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">data</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">arraySize</span><span class="o">];</span>

        <span class="n">Random</span> <span class="n">rnd</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Random</span><span class="o">(</span><span class="n">0</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="o">;</span> <span class="o">++</span><span class="n">c</span><span class="o">)</span>
            <span class="n">data</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="na">nextInt</span><span class="o">()</span> <span class="o">%</span> <span class="n">256</span><span class="o">;</span>

        <span class="c1">// !!! With this, the next loop runs faster
</span><span class="c1"></span>        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>

        <span class="c1">// Test
</span><span class="c1"></span>        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">100000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
            <span class="c1">// Primary loop
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="o">;</span> <span class="o">++</span><span class="n">c</span><span class="o">){</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">[</span><span class="n">c</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">128</span><span class="o">)</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">data</span><span class="o">[</span><span class="n">c</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">1000000000</span><span class="o">.</span><span class="na">0</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;sum = &#34;</span> <span class="o">+</span> <span class="n">sum</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><ul>
<li><code>--&gt;</code>: <code>--</code>(后减) + <code>&gt;</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//执行的顺序就是：先 x &gt; 0，然后 x--, 表示从x到0.
</span><span class="c1"></span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>
<p>引用 &amp; 指针</p>
<ul>
<li>重复绑定对象</li>
<li>空间占用</li>
<li>多层嵌套</li>
<li>赋值-&gt;<code>NULLPTR</code></li>
<li>相关算数运算 [本质内存地址相关计算]</li>
<li>(间址)访问用的符号不一样: <code>./*/-&gt;</code>, 共三个符号</li>
<li>绑定临时对象, 指针容易引起 <strong>段错误</strong>.</li>
<li>引用用于函数的参数和返回值, 指针不可以.
<ul>
<li><strong>C++ 标准并没有明确要求编译器该如何实现引用，但是基本上所有编译器在底层处理上都会把引用当作指针来处理。</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>遍历字符串中的单词</p>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//001
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="p">....</span>
	<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;Somewhere down the road&#34;</span><span class="p">;</span>
    <span class="n">istringstream</span> <span class="nf">iss</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="k">do</span><span class="p">{</span>
        <span class="n">string</span> <span class="n">subs</span><span class="p">;</span>
        <span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">subs</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Substring: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">subs</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iss</span><span class="p">);</span>

<span class="c1">//002
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span><span class="cp"></span><span class="p">....</span>
    <span class="n">string</span> <span class="n">sentence</span> <span class="o">=</span> <span class="s">&#34;And I feel fine...&#34;</span><span class="p">;</span>
    <span class="n">istringstream</span> <span class="nf">iss</span><span class="p">(</span><span class="n">sentence</span><span class="p">);</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iss</span><span class="p">),</span>
         <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(),</span>
         <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">));</span>
<span class="cm">/*
</span><span class="cm">vector&lt;string&gt; tokens;
</span><span class="cm">copy(istream_iterator&lt;string&gt;(iss),
</span><span class="cm">     istream_iterator&lt;string&gt;(),
</span><span class="cm">     back_inserter(tokens));
</span><span class="cm">*/</span> <span class="cm">/*
</span><span class="cm">vector&lt;string&gt; tokens{istream_iterator&lt;string&gt;{iss},
</span><span class="cm">                      istream_iterator&lt;string&gt;{}};
</span><span class="cm">*/</span>

</code></pre></div><ul>
<li>
<p><code>explicit</code>: 拒绝隐式转换（implicit conversion）.  添加的位置在 <strong>构造函数前面</strong>.</p>
</li>
<li>
<p><strong>隐式转化:</strong> 在面向对象中, 可以从基本类型通过 构造函数 转化为对应的函数类型.</p>
</li>
<li>
<p><code>using namespace std</code>: 命名冲突有关，与性能是没有关系。两个库函数重名问题.</p>
</li>
<li>
<p>位（bit）</p>
<ul>
<li>0UL 表示 无符号长整型 0 ; 1UL 表示 无符号长整型 1, 不加<code>UL</code>表示<code>INT</code></li>
<li>置 1（bit-set）: <code>number |= 1UL &lt;&lt; n;</code></li>
<li>清零（bit-clear）: <code>number &amp;= ~(1UL &lt;&lt; n);</code></li>
<li>取反（bit-toggle）: <code>number ^= 1UL &lt;&lt; n;</code></li>
<li>检查（bit-check）: <code>bit = (number &gt;&gt; n) &amp; 1U;</code></li>
<li>根据另一个变量来置位: <code>number ^= (-x ^ number) &amp; (1UL &lt;&lt; n);</code></li>
</ul>
</li>
<li>
<p>sql 优化插入操作.</p>
</li>
<li>
<p>类型转换的正确用法和应用场景</p>
<ul>
<li><code>static_cast</code>: 静态转换的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。
<ul>
<li>基本数据类型之间的转换。[安全性开发人员保证]</li>
<li>void 指针转换成目标类型的指针。[安全性开发人员保证]</li>
<li>任何类型的表达式转换成 void 类型。</li>
<li>有转换构造函数或类型转换函数的类与其它类型之间的转换。</li>
<li>类层次结构中基类和子类之间指针或引用的转换。进行上行转换（即子类的指针或引用转换成基类表示）是安全的，不过一般在进行这样的转化时会省略 static_cast；进行下行转换（即基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的，一般用 dynamic_cast 来替代。</li>
</ul>
</li>
<li><code>dynamic_cast</code> : 动态转换, 会在运行期借助 RTTI 进行类型转换（这就要求基类必须包含虚函数），主要用于类层次间的下行转换（即基类指针或引用转换成子类表示）。对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出 std::bad_cast 异常。</li>
<li><code>const_cast</code>: 修改类型的 const 或 volatile 属性</li>
<li><code>reinterpret_cast</code> : 重新解释的意思，顾名思义，reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。</li>
<li>C 语言风格类型转化<code>(type)value</code> + 函数式风格类型转换<code>type(value)</code>
<ul>
<li>其实是一个意思，只是写法风格的差异而已。它涵盖了上面四种<code>*_cast</code>的所有功能，同时它的使用需要完全由程序员自己把控。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>不需要对<code>malloc</code>返回的值进行转换</p>
<ul>
<li>C 中，从 void* 到其它类型的指针是自动转换的，所以无需手动加上类型转换。</li>
<li>在旧式的 C 编译器里，如果一个函数没有原型声明，那么编译器会认为这个函数返回 int。那么，如果碰巧代码里忘记包含头文件 &lt;stdlib.h&gt;，那么编译器看到malloc 调用时，会认为它返回一个 int。</li>
<li>维护的耦合度高.</li>
</ul>
</li>
<li>
<p><code>include</code> 的 <code>&lt;&gt;</code> &amp; <code>&quot;&quot;</code> diff</p>
<ul>
<li><code>&lt;filename&gt;</code>一般会去系统路径和编译器预指定的路径找。</li>
<li><code>&quot;filename&quot;</code>一般会去工程目录下找</li>
</ul>
</li>
<li>
<p>三法則: 简单来说, 为了日后维护方便, C++里三个成员函数缺一不可:</p>
<ul>
<li>
<p>析构函数</p>
</li>
<li>
<p>复制构造函数</p>
</li>
<li>
<p>赋值运算符 (C++)</p>
<ul>
<li>
<p>C++ 会以值语义处理用户自定义类型的对象，这就是说在不同的上下文环境中,</p>
</li>
<li>
<p>关于构造赋值函数 (copy constructor) 的编写**[手动管理资源]**, 国内的教材一般说明是 **开辟额外内存空间**, 其实一般更好的方式是 **在构造函数(constructor)中创建资源，并在析构函数释放资源。** 对于忘记写构造赋值函数 (copy constructor)的后果就是 **析构野指针, 引发 <a href="https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior">未定义行为错误</a>**.</p>
</li>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">// 1. copy constructor
</span><span class="c1"></span>  <span class="n">person</span><span class="p">(</span><span class="k">const</span> <span class="n">person</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">){</span>
      <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
      <span class="n">age</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
  <span class="p">}</span>
            
  <span class="c1">// 2. copy assignment operator
</span><span class="c1"></span>  <span class="n">person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">person</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">){</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">that</span><span class="p">){</span>
          <span class="k">delete</span><span class="p">[]</span> <span class="n">name</span><span class="p">;</span>
          <span class="c1">// This is a dangerous point in the flow of execution!
</span><span class="c1"></span>          <span class="c1">// We have temporarily invalidated the class invariants,
</span><span class="c1"></span>          <span class="c1">// and the next statement might throw an exception,
</span><span class="c1"></span>          <span class="c1">// leaving the object in an invalid state :(
</span><span class="c1"></span>          <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
          <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
          <span class="n">age</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></li>
<li>
<p>注意，初始化构造和赋值的区别是：在对<code>name</code>赋值前需要先释放其内存。同时也需要自检查，如果没有自检查，<code>delete[] name</code>会将<code>that</code>对象的字符串也析构掉。</p>
</li>
<li>
<p>异常安全: 然而，在因为内存耗尽<code>new char[...]</code>抛出异常的时候，赋值运算符就无法保持 <a href="https://en.wikipedia.org/wiki/Exception_safety">强异常安全保证</a>。可以利用一个局部变量来解决这个问题，</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// 2. copy assignment operator
</span><span class="c1"></span><span class="n">person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">person</span><span class="o">&amp;</span> <span class="n">that</span><span class="p">){</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">local_name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">that</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="c1">// If the above statement throws,
</span><span class="c1"></span>    <span class="c1">// the object is still in the same state as before.
</span><span class="c1"></span>    <span class="c1">// None of the following statements will throw an exception :)
</span><span class="c1"></span>    <span class="n">strcpy</span><span class="p">(</span><span class="n">local_name</span><span class="p">,</span> <span class="n">that</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">local_name</span><span class="p">;</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这同时也解决了自赋值的问题，不需要显示检查是否是自身赋值。其实，还有一个更好的办法可以解决这个问题：<a href="https://github.com/EthsonLiu/stackoverflow-top-cpp/blob/master/question/016%20-%20copy-and-swap%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.md">copy-and-swap</a>，不过不在这里作深入讨论，读者可以跟随链接具体了解。</p>
<p>我之所以在此处提及异常，是想说：手写一个管理资源的类并不是我们想象中的那么容易。</p>
</li>
<li>
<p>C++11 以来特殊成员函数大家庭又新加入了两名成员：移动构造函数和移动赋值运算符。</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">person</span><span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
          
<span class="k">public</span><span class="o">:</span>
    <span class="n">person</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">);</span>        <span class="c1">// Ctor
</span><span class="c1"></span>    <span class="n">person</span><span class="p">(</span><span class="k">const</span> <span class="n">person</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>                <span class="c1">// Copy Ctor
</span><span class="c1"></span>    <span class="n">person</span><span class="p">(</span><span class="n">person</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>            <span class="c1">// Move Ctor
</span><span class="c1"></span>    <span class="n">person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">person</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>     <span class="c1">// Copy Assignment
</span><span class="c1"></span>    <span class="n">person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">person</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// Move Assignment
</span><span class="c1"></span>    <span class="o">~</span><span class="n">person</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>                    <span class="c1">// Dtor
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div></li>
<li>
<p>智能指针管理类???</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>[运算符重载.](&lt;https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading)</p>
</li>
<li>
<p><code>??!??!</code>符号: <code>??!</code>是一个 <a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E5%AD%97%E7%AC%A6%E7%BB%84%E4%B8%8E%E5%8F%8C%E5%AD%97%E7%AC%A6%E7%BB%84">三字符组</a>，编译器会自动翻译成<code>|</code>, <code>{ | } ~ </code> 都有这样的转化.[历史原因<a href="https://zh.wikipedia.org/wiki/EBCDIC">-EBCDIC</a>]</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="o">!</span><span class="n">ErrorHasOccured</span><span class="p">()</span> <span class="o">??!??!</span> <span class="n">HandleError</span><span class="p">();</span>
</code></pre></div></li>
<li>
<p>内存模型</p>
</li>
<li>
<p>C++ 的标准输入流慢于 Python</p>
<ul>
<li>默认情况下，cin 与 stdin 总是保持同步的，也就是说这两种方法可以混用，而不必担心文件指针混乱，同时 cout 和 stdout 也一样，两者混用不会输出顺序错乱。正因为这个兼容性的特性，导致 cin 有许多额外的开销，如何禁用这个特性呢<code>std::ios_base::sync_with_stdio(false);</code> 这样就可以取消 cin 于 stdin 的同步了。但是会导致<code>scanf</code>&amp;<code>cin</code>混用缓冲区冲突的问题.</li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/375913/how-can-i-profile-c-code-running-on-linux">Linux分析C++性能?</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one">智能指针</a></p>
<ul>
<li>利用了 RAII（资源获取即初始化）技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。C++ 标准一共有四种智能指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr。其中 auto_ptr 在 C++11 已被摒弃，C++17 中被移除不可用了。</li>
<li>作用:
<ul>
<li>防止忘记调用 delete。</li>
<li>异常安全</li>
</ul>
</li>
<li>主要是<strong>从 value 语义转化为 reference 语义</strong></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file">目前使用模板的唯一方法就是在头文件中实现为内联。</a></p>
</li>
<li>
<p><code>:-!!</code></p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* Force a compilation error if condition is true, but also produce a
</span><span class="cm">   result (of value 0 and type size_t), so the expression can be used
</span><span class="cm">   e.g. in a structure initializer (or where-ever else comma expressions
</span><span class="cm">   aren&#39;t permitted). */</span>
<span class="cp">#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
</span><span class="cp">#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))
</span></code></pre></div><ul>
<li><code>(e)</code>：计算 e 表达式</li>
<li><code>!!(e)</code>：两次逻辑否操作。也就是，如果 e == 0，就返回 0，否则返回 1</li>
<li><code>-!!(e)</code>：对上面的第 2 步得到的值置负。也就是，0 的负数还是 0，1 的负数为 -1</li>
<li><code>struct{int: -!!(0);} --&gt; struct{int: 0;}</code>：根据第 3 步，如果是 0，那么就声明一个结构体，里边定义了一个位域长度为 0 的匿名位域变量，此时编译正常通过</li>
<li><code>struct{int: -!!(1);} --&gt; struct{int: -1;}</code>：但如果是 -1 的话，位域长度为负数，那编译器就会报错了</li>
<li>因为<code>assert</code>是运行期判断，上面的宏是编译期。不过自 C++ 11 起，也支持静态断言了，可以参考 <a href="https://zh.cppreference.com/w/cpp/language/static_assert">static_assert</a></li>
</ul>
</li>
<li>
<p>移动语义（move semantics）</p>
<ul>
<li>
<p>在函数嵌套写法中, 会造成同一个变量的数据从运算结果到匿名变量再到指定变量中 (如<code>string b(x + y);</code>, <code>x+y</code>-&gt;<code>匿名变量</code>-&gt;<code>b</code>), 这个时候如果用移动构造函数, 把匿名函数的内存空间拿给指定变量中, 时间复杂度就可以降下来.</p>
</li>
<li>
<p><strong>写法:</strong> 右值引用<code>&amp;&amp;</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="n">string</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">that</span><span class="p">){</span> <span class="c1">// 这个叫做移动构造函数
</span><span class="c1"></span>        <span class="n">data</span> <span class="o">=</span> <span class="n">that</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
        <span class="n">that</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>C 语言中, <code>a[5] == 5[a]</code></p>
<ul>
<li>C语言定义<code>[]</code> 为 <code> a[b] == *(a + b)</code></li>
</ul>
</li>
<li>
<p>使用指针而不是对象本身？</p>
<ul>
<li><strong>生命周期</strong>
<ul>
<li>对象被创建在栈上，它的特点就是脱离作用域后会自动销毁。</li>
<li>指针在堆上动态创建一个对象，它的特点就是即使脱离作用域，该对象也会一直存在，除非你手动释放（delete）它，否则就会出现内存泄漏。</li>
</ul>
</li>
<li><strong>什么时候使用 new</strong>
<ul>
<li><strong>延长对象生命周期。</strong></li>
<li><strong>你需要很多内存。</strong></li>
</ul>
</li>
<li><strong>什么时候使用指针</strong>
<ul>
<li><strong>引用语义（reference semantics）：</strong> 有的时候，你希望函数传递进来的参数不是一份副本（copy），因为创建副本的代价很大。这个时候，你就可以通过指针。不过 C++ 11 已经有了移动（move）语义，这个问题就不用担心了。</li>
<li><strong>多态（polymorphic）：</strong> 对于多态类型，指针和引用可以避免对象被切片（slice）。切片的意思就是说：在函数传参处理多态变量时，如果一个派生类对象在向上转换（upcast），用的是传值的方式，而不是指针和引用，那么，这个派生类对象在 upcast 以后，将会被 slice 成基类对象，也就是说，派生类中独有的成员变量和方法都被 slice 掉了，只剩下和基类相同的成员变量和属性。</li>
<li>希望表示对象是可选的（optional）：** 指针可以被赋值为 nullptr，也就是空的意思，你可以通过设置指针为 nullptr，来表达忽略该变量的含义。C++ 17 新增了 <code>std::optional</code>，那么这个问题也可以得到解决。</li>
<li><strong>你想通过解耦编译单元来减少编译时间：</strong>  如果对象都是指针指向的，那么只需要这个类型的前向声明就可以。这可以分离编译过程的各个部分，会显著提高编译时间。</li>
<li><strong>兼容 C 库：</strong> C 库的接口大多都是以指针返回对象，这个时候你就不得不用指针。当然你也可以使用智能指针来封装它，这样使用起来就方便了。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>extern &ldquo;c&rdquo; 是什么意思？</p>
<ul>
<li><code>extern &quot;C&quot;</code> 用来告诉 <strong>C++ 编译器</strong>，这部分代码要按照 C 语言的方式去链接。</li>
</ul>
</li>
<li>
<p>将 0.1f 更改为 0 性能会降低 10 倍？.md</p>
<ul>
<li>**由<a href="https://blog.csdn.net/AaricYang/article/details/91358149">非规格化浮点数</a>造成的。**处理器对非规格化浮点数的处理效率比规格化浮点数要慢 10-100 倍。下面是针对上面的代码所做的测试</li>
</ul>
</li>
<li>
<p>数字转字符串</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-CPP" data-lang="CPP">  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
      <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="o">=</span><span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">str</span><span class="o">&lt;&lt;</span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        
      <span class="c1">//char *instr=std::itoa(a);
</span><span class="c1"></span>      <span class="c1">//std::string stri = std::string(instr);
</span><span class="c1"></span>      <span class="c1">//std::cout&lt;&lt;stri&lt;&lt;&#39;\n&#39;;
</span><span class="c1"></span>      <span class="c1">//Portability This function is not defined in ANSI-C 
</span><span class="c1"></span>      <span class="c1">// and is not part of C++, but is supported by some compilers.
</span><span class="c1"></span>        
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>什么时候该定义虚析构函数，为什么要这么做？</p>
<ul>
<li>当你通过一个基类指针去删除（delete）派生对象的时候，虚析构函数就很用了。</li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11%3E">C++11 中的 lambda 表达式是什么</a></p>
</li>
<li>
<p><code>const int *</code>, <code>const int * const</code> 和 <code>int const *</code></p>
<ul>
<li><code>int * p</code> - p is pointer to int</li>
<li><code>int const * p</code> - p is pointer to const int</li>
<li><code>int * const p</code> - p is const pointer to int</li>
<li><code>int const * const p</code> - p is const pointer to const int</li>
</ul>
<p>其中，下面两个是等同的，只是顺序的不同而已，</p>
<ul>
<li>const int * == int const *</li>
<li>const int * const == int const * const</li>
</ul>
<p>当然还有更复杂的，</p>
<ul>
<li><code>int ** p</code> - p is pointer to pointer to int</li>
<li><code>int ** const p</code> - p is const pointer to pointer to int</li>
<li><code>int * const * p</code> - p is pointer to const pointer to int</li>
<li><code>int const ** p</code> - p is pointer to pointer to const int</li>
<li><code>int * const * const p</code> - p is const pointer to const pointer to int</li>
<li><a href="https://ethsonliu.com/2020/04/reading-c-type-declarations.html">读懂 C 的类型声明（译）</a></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c">虚函数的重要性</a>?</p>
</li>
<li>
<p>C 语言中的函数指针是怎么用的？</p>
</li>
<li>
<p>POD: Plain Old Data</p>
<ul>
<li>C++ 中的 Plain Old Data Structure 是一个聚合类，仅包含 POD 成员，没有自定义的析构函数，没有自定义的赋值运算符，并且没有非静态成员指针。</li>
</ul>
</li>
<li>
<p>extern 关键字在不同的源文件间共享变量</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="k">extern</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 声明，a 的定义可能在其它的文件
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 定义，b 占有实际的内存
</span></code></pre></div></li>
</ul>
</li>
<li>
<p>将一个大的数组的所有成员初始化为相同的值？</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">//C
</span><span class="c1"></span>  <span class="c1">// 1.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">myArray</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span> <span class="c1">// initialize to 1,2,0,0,0..
</span><span class="c1"></span>        
  <span class="c1">// 2.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">myArray</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span> <span class="c1">// all elements 0
</span><span class="c1"></span>        
  <span class="c1">// 3.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">myArray</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">myArray</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">myArray</span><span class="p">));</span>
        
  <span class="c1">//c++
</span><span class="c1"></span>  <span class="c1">//1
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">myArray</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// all elements 0 in C++, but is not allowed with C
</span><span class="c1"></span>  <span class="c1">//2
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">myArray</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="n">fill</span><span class="p">(</span><span class="n">myArray</span><span class="p">,</span> <span class="n">myArray</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 数组元素都会被赋值为 3
</span></code></pre></div></li>
</ul>
</li>
<li>
<p>确定数组的元素个数</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">//1
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="c1">// size_t n = sizeof(a) / sizeof(a[0]);
</span><span class="c1"></span>  <span class="c1">//2 large size -&gt; define
</span><span class="c1"></span>  <span class="cp">#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))
</span><span class="cp"></span>  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
  <span class="n">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">NELEMS</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>switch case 里面不可以定义变量, 需要加作用域副号.</p>
</li>
<li>
<p>Struct &amp; Class</p>
<ul>
<li>仅当成员都是 POD 类型且都是 public 的时候用 <code>struct</code>。</li>
</ul>
</li>
<li>
<p>构造函数里面调用构造函数</p>
<ul>
<li>在 C++11 中可以</li>
</ul>
</li>
<li>
<p>std::string 转 const char * 或者 char * 类型</p>
<ul>
<li>
<p><code>string::c_str()</code> 的返回类型就是 <code>const char *</code>，末尾带结束符 <code>\0</code></p>
</li>
<li>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><code>typedef</code> &amp;  <code>using</code> 区别</p>
<ul>
<li>除了 <code>using</code> 还可以在模板中使用，其它的都是等同的</li>
</ul>
</li>
<li>
<p>C++ 程序员应尽量避免使用 <code>new</code></p>
<ul>
<li>
<p>C++ 并不带自动 GC。任何的 <code>new</code> 都需要有对应的 <code>delete</code>，否则就会有内存泄漏。</p>
</li>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">someString</span> <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(...);</span> <span class="c1">//1
</span><span class="c1"></span>  <span class="k">delete</span> <span class="n">someString</span><span class="p">;</span>
        
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">someString</span><span class="p">(...);</span><span class="c1">//2
</span></code></pre></div></li>
<li>
<p>这就是 <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> 技术。当离开它的作用域的时候，<code>someString</code> 便会自动析构。而且 C++11 完善了智能指针，旨在可以更方便地帮助我们实现 RAII，我们可以适当地加以利用。</p>
</li>
</ul>
</li>
<li>
<p>仿函数</p>
<ul>
<li>重载了括号运算符 () 的对象, 不过它具有函数的一些性质, 可以在需要函数的地方（主要是<strong>各种容器和算法</strong>）使用。</li>
<li>仿函数可以拥有（多个）状态。</li>
<li>C++11 带来了 <code>std::bind</code> 和 <code>std::function</code>，它们也可以完成仿函数的工作。</li>
</ul>
</li>
<li>
<p>typeof struct</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="k">typedef</span> <span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="n">Foo</span><span class="p">;</span> <span class="c1">// 1 定义一个名称是 Foo 的结构体，并别名 Foo；
</span><span class="c1"></span>  <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="n">Foo</span><span class="p">;</span>     <span class="c1">// 2 定义一个匿名的结构体，并别名 Foo。
</span><span class="c1"></span>  <span class="c1">//两者的区别就是后者无法被前置声明
</span></code></pre></div></li>
<li>
<p>C 标准（<a href="http://port70.net/~nsz/c/c89/c89-draft.txt">C89 §3.1.2.3</a>, <a href="http://port70.net/~nsz/c/c99/n1256.html#6.2.3">C99 §6.2.3</a>, <a href="http://port70.net/~nsz/c/c11/n1570.html#6.2.3">C11 §6.2.3</a>）把不同类型的标识符（identifier）分到不同的命名空间（namespace）。例如标签标识符（tag identifiers）struct/union/enum 在标签命名空间，普通标识符（ordinary identifiers），typedef 修饰的别名和其它类型都在普通命名空间。C语言中<code>struct Foo { ... }; Foo x;</code>这样的用法会报错</p>
</li>
</ul>
</li>
<li>
<p>i++ &amp; ++i</p>
<ul>
<li>在 for 语句中，建议使用 <code>++i</code>。如果 i 是一个基本类型（short/int/&hellip;）的话，<code>++i</code> 和 <code>i++</code> 其实没什么区别。但如果 i 是一个自定义类型的话，它的 <code>operator++</code> 后自加重载比前自加多了一次临时对象的构造，所以从效率上讲，前自加更快。因此，不管是从习惯，还是风格一致上来讲，前自加 <code>++i</code> 是更好的选择。</li>
</ul>
</li>
<li>
<p>声明 &amp; 定义</p>
<ul>
<li>声明不分配存储空间，定义会分配</li>
<li>声明可以多次，但定义只能一次</li>
</ul>
</li>
<li>
<p>接口</p>
<ul>
<li>
<p>CPP 没有接口这个说法，但有虚函数, 可以实现类似接口的功能。</p>
</li>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="k">class</span> <span class="nc">IDemo</span><span class="p">{</span> <span class="c1">// “接口”
</span><span class="c1"></span>      <span class="k">public</span><span class="o">:</span>
          <span class="k">virtual</span> <span class="o">~</span><span class="n">IDemo</span><span class="p">()</span> <span class="p">{}</span>
          <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OverrideMe</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>
        
  <span class="k">class</span> <span class="nc">Parent</span><span class="p">{</span>
      <span class="k">public</span><span class="o">:</span>
          <span class="k">virtual</span> <span class="o">~</span><span class="n">Parent</span><span class="p">();</span>
  <span class="p">};</span>
        
  <span class="k">class</span> <span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span><span class="p">,</span> <span class="k">public</span> <span class="n">IDemo</span><span class="p">{</span>
      <span class="k">public</span><span class="o">:</span>
          <span class="k">virtual</span> <span class="kt">void</span> <span class="n">OverrideMe</span><span class="p">(){</span>
              <span class="c1">//do stuff
</span><span class="c1"></span>          <span class="p">}</span>
  <span class="p">};</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>去除 <code>std::string</code> 头尾空格</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">// trim from start (in place)
</span><span class="c1"></span>  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ltrim</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
      <span class="p">}));</span>
  <span class="p">}</span>
        
  <span class="c1">// trim from end (in place)
</span><span class="c1"></span>  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rtrim</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">s</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">ch</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">isspace</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
      <span class="p">}).</span><span class="n">base</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>
        
  <span class="c1">// trim from both ends (in place)
</span><span class="c1"></span>  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">trim</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ltrim</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
      <span class="n">rtrim</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>宏定义里加<code>while(1)</code>的意义</p>
<ul>
<li>其实是为了把这个宏模拟成一条真实的语句。但总有人会忘记加上 <code>{}</code>。所以加上 do-while 或者 if-else 就可以解决这个问题。`</li>
</ul>
</li>
<li>
<p><code>malloc</code> &amp; <code>calloc</code></p>
<ul>
<li><code>calloc</code> 会申请内存，并全初始化为 0；而 <code>malloc</code> 只申请内存，并不作初始化。所以 <code>calloc</code> 的执行会比 <code>malloc</code> 稍微费时，因为它多了初始化的步骤。</li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/11694546/divide-a-number-by-3-without-using-operators%3E">不使用加、减、乘、除、取余的情况下，实现除以 3 的功能</a></p>
</li>
<li>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="c1">// replaces the + operator
</span><span class="c1"></span>    <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">y</span> <span class="o">^=</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
        
    <span class="kt">int</span> <span class="nf">divideby3</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
    <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>C 语言布尔类型</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;//1. 只在 C99 有效，如果可以，建议使用这个。</span><span class="cp">
</span><span class="cp"></span>    
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span> <span class="p">}</span> <span class="kt">bool</span><span class="p">;</span><span class="c1">//2
</span><span class="c1"></span>    
<span class="k">typedef</span> <span class="kt">int</span> <span class="kt">bool</span><span class="p">;</span><span class="c1">//3
</span><span class="c1"></span><span class="k">enum</span> <span class="p">{</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span> <span class="p">};</span>
    
<span class="k">typedef</span> <span class="kt">int</span> <span class="kt">bool</span><span class="p">;</span><span class="c1">//4
</span><span class="c1"></span><span class="cp">#define true 1
</span><span class="cp">#define false 0
</span></code></pre></div></li>
</ul>
</li>
<li>
<p><code>std::string</code> 全部转为小写字母</p>
</li>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>    
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data</span> <span class="o">=</span> <span class="s">&#34;Abc&#34;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
    <span class="p">[](</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">){</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">tolower</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="p">});</span>
</code></pre></div></li>
<li>
<p>对象切割（object slicing）</p>
<ul>
<li>切割: 把一个子类对象赋给父类，那么相比父类，子类对象多出的成员会被丢弃掉</li>
</ul>
</li>
<li>
<p><code>push_back</code> 和 <code>emplace_back</code> 的区别</p>
<ul>
<li><code>emplace_back</code> 能就地通过参数构造对象，不需要拷贝或者移动内存，相比 <code>push_back</code> 能更好地避免内存的拷贝与移动，使容器插入元素的性能得到进一步提升。在大多数情况下应该优先使用 <code>emplace_back</code> 来代替 <code>push_back</code>。</li>
</ul>
</li>
<li>
<p>C++ 实现一个单例模式</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">S</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">static</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">getInstance</span><span class="p">(){</span>
            <span class="k">static</span> <span class="n">S</span> <span class="n">instance</span><span class="p">;</span> <span class="c1">// C++11 保证这是线程安全的
</span><span class="c1"></span>            <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">S</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">S</span><span class="p">(</span><span class="n">S</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 《Effective Modern C++》提到，用 delete 更有益于编译器的错误提示
</span><span class="c1"></span>        <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">S</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span>  <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>成员函数结尾加<code>const</code></p>
<ul>
<li>表示该函数不允许修改成员变量（除 <code>mutable</code> 修饰的变量），且也只能调用 <code>const</code> 成员函数</li>
</ul>
</li>
<li>
<p>C++ 标准规定类型 int 和 long 的长度大小</p>
</li>
<li>
<pre><code>sizeof(char) == 1
sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)
    
sizeof(signed char)   == 1
sizeof(unsigned char) == 1
    
sizeof(short)     &gt;= 2
sizeof(int)       &gt;= 2
sizeof(long)      &gt;= 4
sizeof(long long) &gt;= 8
</code></pre></li>
<li>
<p>结构体sizeof 不等于每个成员的 sizeof 之和</p>
<ul>
<li><a href="http://www.catb.org/esr/structure-packing/">失传的C结构体打包技艺 &ndash; 内存对齐</a></li>
</ul>
</li>
<li>
<p>拼接两个<code> std::vector</code></p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">// vector2 拷贝到 vector1
</span><span class="c1"></span>  <span class="n">vector1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vector1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">vector2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vector2</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        
  <span class="c1">// vector2 移动到 vector1，此时 vector2 不可再用
</span><span class="c1"></span>  <span class="n">vector1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">vector1</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">vector2</span><span class="p">.</span><span class="n">begin</span><span class="p">()),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_move_iterator</span><span class="p">(</span><span class="n">vector2</span><span class="p">.</span><span class="n">end</span><span class="p">()));</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>用 static_cast 取代 C 语言的强制转换</p>
<ul>
<li>是对的，C 式的强制转换看不出语义，也不利用编译器的错误检查，具体参考：<a href="https://github.com/EthsonLiu/stackoverflow-top-cpp/blob/master/question/010%20-%20static_cast%2C%20dynamic_cast%2C%20const_cast%20%E5%92%8C%20reinterpret_cast%20%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F.md">static_cast, dynamic_cast, const_cast 和 reinterpret_cast 怎么用？</a></li>
</ul>
</li>
<li>
<p>拼接字符串</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#34;John&#34;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result</span><span class="p">;</span>
        
  <span class="c1">// 1. with C++11 
</span><span class="c1"></span>  <span class="c1">// 安全。
</span><span class="c1"></span>  <span class="c1">// 需要 C++11 的支持，需 `#include &lt;string&gt;`，标准所支持，跨平台。
</span><span class="c1"></span>  <span class="n">result</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">age</span><span class="p">);</span>
        
  <span class="c1">// 2. with IOStreams
</span><span class="c1"></span>  <span class="c1">//安全、低效、代码啰嗦。
</span><span class="c1"></span>  <span class="c1">// 需 `#include &lt;sstream&gt;`，标准所支持，跨平台。
</span><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">sstm</span><span class="p">;</span>
  <span class="n">sstm</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">age</span><span class="p">;</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">sstm</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        
  <span class="c1">// 3. with itoa
</span><span class="c1"></span>  <span class="c1">// 容易出错（你需要分配足够的内存）、快速、代码啰嗦。
</span><span class="c1"></span>  <span class="c1">// `itoa` 不是一个标准方法，不确定可以在所有平台适用。
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">numstr</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span> <span class="c1">// enough to hold all numbers up to 64-bits
</span><span class="c1"></span>  <span class="n">result</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">itoa</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="n">numstr</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
        
  <span class="c1">// 4. with sprintf
</span><span class="c1"></span>  <span class="c1">// 容易出错（你需要分配足够的内存）、快速、代码啰嗦。
</span><span class="c1"></span>  <span class="c1">// 标准所支持，跨平台。
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">numstr</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span> <span class="c1">// enough to hold all numbers up to 64-bits
</span><span class="c1"></span>  <span class="n">sprintf</span><span class="p">(</span><span class="n">numstr</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span> <span class="n">numstr</span><span class="p">;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>检测无符号整数溢出</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">// 加法检测
</span><span class="c1"></span>  <span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span> <span class="cm">/* `a + x` would overflow */</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">INT_MIN</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span> <span class="cm">/* `a + x` would underflow */</span><span class="p">;</span>
        
  <span class="c1">// 减法检测
</span><span class="c1"></span>  <span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span> <span class="cm">/* `a - x` would overflow */</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">INT_MIN</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span> <span class="cm">/* `a - x` would underflow */</span><span class="p">;</span>
        
  <span class="c1">// 乘法检测
</span><span class="c1"></span>  <span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">something</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// There may be a need to check for -1 for two&#39;s complement machines.
</span><span class="c1"></span>  <span class="c1">// If one number is -1 and another is INT_MIN, multiplying them we get abs(INT_MIN) which is 1 higher than INT_MAX
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">INT_MIN</span><span class="p">))</span> <span class="cm">/* `a * x` can overflow */</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">INT_MIN</span><span class="p">))</span> <span class="cm">/* `a * x` (or `a / x`) can overflow */</span>
  <span class="c1">// general case
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">INT_MAX</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span> <span class="cm">/* `a * x` would overflow */</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">INT_MIN</span> <span class="o">/</span> <span class="n">x</span><span class="p">))</span> <span class="cm">/* `a * x` would underflow */</span><span class="p">;</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><code>size_t</code> 定义在头文件 <code>stddef.h</code> 中，标准规定它是一个至少 16 位的无符号整型。在我的机器上它是这样的，</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size_t</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>检测一个元素是否在 std::vector 中</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span> 
        
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">item</span><span class="p">)</span> <span class="o">!=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
     <span class="n">do_this</span><span class="p">();</span>
  <span class="k">else</span>
     <span class="nf">do_that</span><span class="p">();</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration">前置声明</a></p>
<ul>
<li>定义一个指针或引用</li>
<li>函数参数或返回值，但没法使用它们的成员变量或函数</li>
</ul>
</li>
<li>
<p>读取文件内容</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">//1. 按空格和换行符进行分割
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">infile</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">){</span>
      <span class="c1">// process pair (a,b)
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="c1">//2. 读取每行，然后按空格分割
</span><span class="c1"></span>  <span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">line</span><span class="p">)){</span>
      <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="n">iss</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iss</span> <span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span><span class="p">))</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
        
      <span class="c1">// process pair (a,b)
</span><span class="c1"></span>  <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>优雅的初始化 std:vector</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++">  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">29</span><span class="p">};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
</code></pre></div></li>
<li>
<p>如果你的编译器支持 C++ 11 的话，可以直接这样，</p>
</li>
<li>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>如何使用 C 或 C++ 获取目录中的文件列表？不使用 <code>ls</code></p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">// Linux 平台
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">dirname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;/usr/local&#34;</span>
  <span class="n">DIR</span> <span class="o">*</span><span class="n">dir_ptr</span><span class="p">;</span>
  <span class="k">struct</span> <span class="nc">dirent</span> <span class="o">*</span><span class="n">direntp</span><span class="p">;</span>
         
  <span class="n">dir_ptr</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="n">dirname</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dir_ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&#34;Ls: can not open %s&#34;</span><span class="p">,</span><span class="n">dirname</span><span class="p">);</span>
  <span class="k">else</span>
  <span class="p">{</span>
      <span class="n">direntp</span> <span class="o">=</span> <span class="n">readdir</span><span class="p">(</span><span class="n">dir_ptr</span><span class="p">);</span>
      <span class="k">while</span><span class="p">(</span><span class="n">direntp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
          <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">direntp</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
            
      <span class="n">closedir</span><span class="p">(</span><span class="n">dir_ptr</span><span class="p">);</span>
  <span class="p">}</span>
        
  <span class="c1">//Windows 平台
</span><span class="c1"></span>  <span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;tchar.h&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="kt">void</span> <span class="nf">_tmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">TCHAR</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
  <span class="p">{</span>
      <span class="n">WIN32_FIND_DATA</span> <span class="n">FindFileData</span><span class="p">;</span>
      <span class="n">HANDLE</span> <span class="n">hFind</span><span class="p">;</span>
        
      <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">{</span>
         <span class="n">_tprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">&#34;Usage: %s [target_file]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
         <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
        
      <span class="n">_tprintf</span> <span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">&#34;Target file is %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
      <span class="n">hFind</span> <span class="o">=</span> <span class="n">FindFirstFile</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">FindFileData</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">hFind</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> 
      <span class="p">{</span>
         <span class="n">printf</span> <span class="p">(</span><span class="s">&#34;FindFirstFile failed (%d)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
         <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span> 
      <span class="k">else</span> 
      <span class="p">{</span>
         <span class="n">_tprintf</span> <span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">&#34;The first file found is %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">),</span> <span class="n">FindFileData</span><span class="p">.</span><span class="n">cFileName</span><span class="p">);</span>
         <span class="n">FindClose</span><span class="p">(</span><span class="n">hFind</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
        
  <span class="c1">//C++17
</span><span class="c1"></span>  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="k">namespace</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="p">;</span>
        
  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">path</span> <span class="o">=</span> <span class="s">&#34;/path/to/directory&#34;</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="nl">entry</span> <span class="p">:</span> <span class="n">fs</span><span class="o">::</span><span class="n">directory_iterator</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
          <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>typename &amp; class 区别, 一些场景下是有区别不可替换的</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">param_t</span><span class="o">&gt;</span><span class="c1">// C++ 允许在类内定义类型别名，
</span><span class="c1"></span>  <span class="k">class</span> <span class="nc">Foo</span>
  <span class="p">{</span>
      <span class="k">typedef</span> <span class="k">typename</span> <span class="n">param_t</span><span class="o">::</span><span class="n">baz</span> <span class="n">sub_t</span><span class="p">;</span>
  <span class="p">};</span>
        
  <span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span><span class="p">,</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Type</span> <span class="o">&gt;</span><span class="c1">// 当定义模板的模板时，也必须用 class
</span><span class="c1"></span>            
  <span class="k">template</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span><span class="c1">//当显式实例化模板的时候，必须用 class
</span></code></pre></div></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/77005/how-to-automatically-generate-a-stacktrace-when-my-program-crashes">有什么好的办法可以在 C/C++ 程序段错误退出时输出堆栈信息，来方便查找错误么？</a></p>
<ul>
<li>在 Linux 平台下可以使用 <code>&lt;execinfo.h&gt;</code> 里的 <code>backtrace_*</code> 函数，详见 <a href="http://www.gnu.org/software/libc/manual/html_node/Backtraces.html">Backtraces</a>.</li>
</ul>
</li>
<li>
<p>static const VS #define VS enum</p>
<ul>
<li>如果需要传指针，那只能用 (1)</li>
<li>(1) 不能作为全局作用域下数组的维数定义，而 (2)(3) 可以</li>
<li>(1) 不能作为函数作用域下静态数组的维数定义，而 (2)(3) 可以</li>
<li>(1) 不能在 switch 语句下使用，而 (2)(3) 可以</li>
<li>(1) 不能用来初始化另一个静态常量，而 (2)(3) 可以</li>
<li>(2) 可以用预处理器判断是否已存在，而 (1)(3) 不可以
<ul>
<li>大多场景下，enum 是最佳选择。 <strong>如果是 C++ 语言，那么自始至终都应该使用 (1)。</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>段错误</strong>: 是由于程序访问了本不属于它的的内存而引起的错误。每当遇到段错误时，你就应该知道程序在内存访问上出错了。比如，访问了已释放的变量、写入只读内存&hellip;&hellip;在大多数语言中，段错误在本质上都是相同的，在 C 和 C++ 中也是一样。要想重现段错误很简单，解引用一个空指针就会出现，</p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/71372182">静态库和动态库</a></p>
<ul>
<li><strong>后缀名不同</strong>:
<ul>
<li>动态库的后缀，在 Windows 上是 <code>.dll</code>，linux 上是 <code>.so</code>，在 OSX 上是 <code>.dylib</code>。</li>
<li>静态库，在 WIndows 上是 <code>.lib</code>，linux 上是 <code>.a</code>。</li>
</ul>
</li>
<li><strong>可执行文件大小不一样</strong>: 静态链接的可执行文件要比动态链接的可执行文件要大得多，因为它将需要用到的代码从二进制文件中“拷贝”了一份，而动态库仅仅是复制了一些重定位和符号表信息。</li>
<li><strong>扩展性与兼容性不一样</strong>: 如果静态库中某个函数的实现变了，那么可执行文件必须重新编译，而对于动态链接生成的可执行文件，只需要更新动态库本身即可，不需要重新编译可执行文件。正因如此，使用动态库的程序方便升级和部署。</li>
<li><strong>依赖不一样</strong>: 静态链接的可执行文件不需要依赖其他的内容即可运行，而动态链接的可执行文件必须依赖动态库的存在。所以如果你在安装一些软件的时候，提示某个动态库不存在的时候也就不奇怪了。即便如此，系统中存在一些大量公用的库，所以使用动态库并不会有什么问题。</li>
<li><strong>加载速度不一样</strong>: 由于静态库在链接时就和可执行文件在一块了，而动态库在加载或者运行时才链接，因此，对于同样的程序，静态链接的要比动态链接加载更快。所以选择静态库还是动态库是空间和时间的考量。但是通常来说，牺牲这点性能来换取程序在空间上的节省和部署的灵活性时值得的，再加上局部性原理，牺牲的性能并不多。</li>
</ul>
</li>
<li>
<p>随机数</p>
<ul>
<li>Linux 平台上建议使用 <a href="https://linux.die.net/man/3/random">random and srandom</a>。如果你需要更安全的随机数，建议使用 <a href="https://github.com/jedisct1/libsodium">libsodium</a> 的接口 <code>randombytes</code>，</li>
</ul>
</li>
<li>
<p>文件所有内容到<code>string</code></p>
<ul>
<li>
<p><a href="http://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html">http://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html</a></p>
</li>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_file_contents</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#34;rb&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">contents</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">fseek</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SEEK_END</span><span class="p">);</span>
      <span class="n">contents</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ftell</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
      <span class="n">std</span><span class="o">::</span><span class="n">rewind</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">contents</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">fp</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
      <span class="k">return</span><span class="p">(</span><span class="n">contents</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">throw</span><span class="p">(</span><span class="n">errno</span><span class="p">);</span>
  <span class="p">}</span>
        
  <span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_file_contents</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">in</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">contents</span><span class="p">;</span>
      <span class="n">in</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">end</span><span class="p">);</span>
      <span class="n">contents</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">tellg</span><span class="p">());</span>
      <span class="n">in</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">beg</span><span class="p">);</span>
      <span class="n">in</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">contents</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="n">in</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
      <span class="k">return</span><span class="p">(</span><span class="n">contents</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/14116003/difference-between-constexpr-and-const">constexpr 和 const</a></p>
<ul>
<li><a href="https://www.zhihu.com/question/35614219">https://www.zhihu.com/question/35614219</a></li>
</ul>
</li>
<li>
<p>nullptr: 一个常量</p>
</li>
<li>
<p><strong>在 C 语言编程中，请使用 <code>NULL</code>。</strong> 此时的 <code>NULL</code>，要么是 <code>((void*)0)</code>，要么是 0，对于 C 语言而言，都无所谓。</p>
</li>
<li>
<p><strong>在 C++ 语言编程中，请使用 <code>nullptr</code>。</strong> 既为了避免以后出现 bug，也为了养成一个良好的编程习惯。<code>nullptr</code> 在实际编程中的应用实在太广泛，因此 C++ 编译器一般都会把 <code>nullptr</code> 定为关键字，避免程序员的滥用。</p>
</li>
<li>
<p>内联函数</p>
<ul>
<li>
<p>内联只是一种建议，并不要求编译器必须执行。如果内联函数本身开销较大（比如含有 for、switch、递归等），编译器可能拒绝内联展开。再者，现代编译器在函数内联的决策处理会比人类手写来的更准确。</p>
</li>
<li>
<p>什么时候该用 inline 函数？</p>
<p>如果这个函数的定义也放在头文件，那么你应该用 inline 修饰它。</p>
</li>
<li>
<p>怎么让编译器不去 inline 函数？</p>
<p>在 GCC 编译器下，可以使用 <code>__attribute__(( noinline ))</code> 修饰；而在 Visual Studio 下，则是 <code>__declspec(noinline)</code>。</p>
</li>
</ul>
</li>
<li>
<p>endl &amp; <code>\n</code></p>
<ul>
<li><code>std::endl</code> 可以刷新输出缓冲区，而 <code>\n</code> 不会。说白了就是下面的代码，</li>
</ul>
</li>
<li>
<p><code>.hpp</code> &amp; <code>.h</code></p>
<ul>
<li>
<p>后缀命名不同的优点：</p>
<ol>
<li>代码自动格式化。一些插件可以根据后缀来自动区分哪个是 C 代码，哪个是 C++，来进行对应的格式化。</li>
<li>语言区分。从后缀就可以很容易区分，这个文件下是 C 还是 C++。</li>
<li>文件命名。C++ 很容易引入 C 库，如果引入了一个 C 库内的头文件 <code>feature.h</code>，而 C++ 不得不对这个文件的代码进行面向对象设计，那么为了保持命名和语义上的统一，将 C++ 文件命名为 <code>feature.hpp</code> 是最佳的选择。</li>
</ol>
</li>
</ul>
</li>
<li>
<p>迭代器失效</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/container">Containers library</a> 下的各个容器都有详细的介绍。例如容器 array 下 <a href="https://en.cppreference.com/w/cpp/container/array#Iterator_invalidation">https://en.cppreference.com/w/cpp/container/array#Iterator_invalidation</a></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/105014/does-the-mutable-keyword-have-any-purpose-other-than-allowing-the-variable-to">mutable</a></p>
<ul>
<li><a href="https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/">https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/</a></li>
</ul>
</li>
<li>
<p>匿名命名空间 &amp; static</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="c1">// 非法代码
</span><span class="c1"></span>  <span class="k">static</span> <span class="k">class</span> <span class="nc">sample_class</span> <span class="p">{</span> <span class="cm">/* class body */</span> <span class="p">};</span>
  <span class="k">static</span> <span class="k">struct</span> <span class="nc">sample_struct</span> <span class="p">{</span> <span class="cm">/* struct body */</span> <span class="p">};</span>
  <span class="c1">// 合法代码
</span><span class="c1"></span>  <span class="k">namespace</span> <span class="p">{</span>  
      <span class="k">class</span> <span class="nc">sample_class</span> <span class="p">{</span> <span class="cm">/* class body */</span> <span class="p">};</span>
      <span class="k">struct</span> <span class="nc">sample_struct</span> <span class="p">{</span> <span class="cm">/* struct body */</span> <span class="p">};</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/10787766/when-should-i-really-use-noexcept">noexcept</a></p>
</li>
<li>
<p><a href="https://ethsonliu.com/2020/04/cpp11-noexcept.html">https://ethsonliu.com/2020/04/cpp11-noexcept.html</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/859634/c-pointer-to-array-array-of-pointers-disambiguation">指针左右问题</a></p>
</li>
<li>
<p><a href="https://ethsonliu.com/2020/04/reading-c-type-declarations.html">https://ethsonliu.com/2020/04/reading-c-type-declarations.html</a></p>
</li>
<li>
<p>CPP 获取 Shell</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">exec</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">128</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">FILE</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pclose</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pipe</span><span class="p">(</span><span class="n">popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">),</span> <span class="n">pclose</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pipe</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&#34;popen() failed!&#34;</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">pipe</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">result</span> <span class="o">+=</span> <span class="n">buffer</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/18335861/why-is-enum-class-preferred-over-plain-enum">enum class &amp; enum</a></p>
</li>
<li>
<p>宏来判断当前的系统类型</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="cp">#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
</span><span class="cp"></span>     <span class="c1">//define something for Windows (32-bit and 64-bit, this part is common)
</span><span class="c1"></span>     <span class="cp">#ifdef _WIN64
</span><span class="cp"></span>        <span class="c1">//define something for Windows (64-bit only)
</span><span class="c1"></span>     <span class="cp">#else
</span><span class="cp"></span>        <span class="c1">//define something for Windows (32-bit only)
</span><span class="c1"></span>     <span class="cp">#endif
</span><span class="cp"></span>  <span class="cp">#elif __APPLE__
</span><span class="cp"></span>      <span class="cp">#include</span> <span class="cpf">&lt;TargetConditionals.h&gt;</span><span class="cp">
</span><span class="cp"></span>      <span class="cp">#if TARGET_IPHONE_SIMULATOR
</span><span class="cp"></span>           <span class="c1">// iOS Simulator
</span><span class="c1"></span>      <span class="cp">#elif TARGET_OS_IPHONE
</span><span class="cp"></span>          <span class="c1">// iOS device
</span><span class="c1"></span>      <span class="cp">#elif TARGET_OS_MAC
</span><span class="cp"></span>          <span class="c1">// Other kinds of Mac OS
</span><span class="c1"></span>      <span class="cp">#else
</span><span class="cp"></span>      <span class="cp">#   error &#34;Unknown Apple platform&#34;
</span><span class="cp"></span>      <span class="cp">#endif
</span><span class="cp"></span>  <span class="cp">#elif __linux__
</span><span class="cp"></span>      <span class="c1">// linux
</span><span class="c1"></span>  <span class="cp">#elif __unix__ </span><span class="c1">// all unices not caught above
</span><span class="c1"></span>      <span class="c1">// Unix
</span><span class="c1"></span>  <span class="cp">#elif defined(_POSIX_VERSION)
</span><span class="cp"></span>      <span class="c1">// POSIX
</span><span class="c1"></span>  <span class="cp">#else
</span><span class="cp"></span>  <span class="cp">#   error &#34;Unknown compiler&#34;
</span><span class="cp"></span>  <span class="cp">#endif
</span></code></pre></div></li>
</ul>
</li>
<li>
<p>程序所在的目录</p>
<ul>
<li>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getexepath</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="n">result</span><span class="p">[</span> <span class="n">MAX_PATH</span> <span class="p">];</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span> <span class="n">result</span><span class="p">,</span> <span class="n">GetModuleFileName</span><span class="p">(</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">MAX_PATH</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span><span class="c1">// window
</span><span class="c1"></span>        
  <span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
</span><span class="cp"></span>  <span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>        
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getexepath</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="kt">char</span> <span class="n">result</span><span class="p">[</span> <span class="n">PATH_MAX</span> <span class="p">];</span>
    <span class="n">ssize_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">readlink</span><span class="p">(</span> <span class="s">&#34;/proc/self/exe&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">PATH_MAX</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span> <span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="nl">count</span> <span class="p">:</span> <span class="mi">0</span> <span class="p">);</span>
  <span class="p">}</span><span class="c1">//linux
</span></code></pre></div></li>
<li>
<p><a href="https://stackoverflow.com/questions/670734/pointer-to-class-data-member">指向类成员的指针</a></p>
<ul>
<li>pointer to member</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto">decltypeauto</a></p>
</li>
</ul>
<br>
<p><strong>Over!</strong></p>
<h2 id="link-链接">LINK 链接</h2>
<ul>
<li><a href="https://www.zhihu.com/question/27417946/">C 语言有什么奇技淫巧？</a></li>
</ul>
<p><img src="https://z3.ax1x.com/2021/06/28/RNt0kn.png" alt=""></p>
<div id="j1"> [1]. https://github.com/ethsonliu/stackoverflow-top-cpp </div>
    
</article>


        <footer>
            <p>
            <a href=./index.xml style=" border-bottom-width: 0px"><svg t="1623645011149" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5933" width=".9em" height=".9em" fill=#8a8a8a><path d="M239.8 672.2c-61.6 0-111.8 50.2-111.8 111.6 0 61.6 50.2 111.2 111.8 111.2 61.8 0 111.8-49.8 111.8-111.2C351.6 722.4 301.6 672.2 239.8 672.2zM239.8 863c-44 0-79.8-35.6-79.8-79.2 0-43.8 35.8-79.6 79.8-79.6 44 0 79.8 35.8 79.8 79.6C319.6 827.4 283.8 863 239.8 863z" p-id="5934"></path><path d="M128 384l0 159.8c96 0 188.2 28.4 256 96.2 67.8 67.8 96 159.8 96 256l160 0C640 616.2 408 384 128 384zM607 864l-96 0c-6.2-99.4-42-184.2-104.4-246.6C344.2 554.8 260 519 160 512.8l0-95.6c52 3.6 104.2 16 153.4 37 57 24.4 108.4 59.2 152.8 103.6 44.4 44.4 79.2 95.8 103.6 152.8C591 759.8 603.4 811.2 607 864z" p-id="5935"></path><path d="M128 128l0 159.8c342 0 607.8 266 607.8 608.2L896 896C896 472.6 552 128 128 128zM582.8 441C470.8 328.8 322 264 160 256.4L160 160.6C540 177 847 483.6 863.4 864l-96.4 0C759.4 702.2 694.6 553 582.8 441z" p-id="5936"></path></svg></a>
            &nbsp;
            <a href="//github.com/bgzocg" style=" border-bottom-width: 0px"><svg t="1623645573680" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7467" width=".9em" height=".9em" fill=#8a8a8a><path d="M427.392 853.504a61.44 61.44 0 0 1-1.450667 15.530667 92.586667 92.586667 0 0 1-10.965333 27.605333c-15.061333 25.301333-40.661333 42.154667-73.642667 42.154667-77.653333 0-108.117333-38.101333-146.261333-133.504C169.216 740.693333 157.013333 725.461333 128 725.461333v-85.333333c77.653333 0 108.117333 38.101333 146.261333 133.504 25.856 64.597333 38.058667 79.786667 67.072 79.786667 0-12.373333-0.170667-23.296-0.512-38.144-0.853333-34.816-0.938667-41.941333 0.554667-51.2 0.64-20.352 5.888-34.773333 16.384-49.066667-95.232-20.736-159.445333-63.573333-196.309333-132.992l-13.824-32.426667C134.186667 510.848 128 467.072 128 416.426667c0-58.24 17.749333-110.336 50.944-153.856-10.368-41.386667-8.96-91.989333 13.909333-149.077334l7.466667-18.688 19.2-6.101333c2.56-0.853333 5.632-1.578667 9.301333-2.133333 37.290667-5.888 90.325333 8.106667 159.701334 52.48a565.930667 565.930667 0 0 1 127.274666-14.208c38.741333 0 77.226667 3.882667 114.048 11.605333 67.456-42.24 119.04-55.509333 155.306667-49.92 3.626667 0.597333 6.741333 1.322667 9.258667 2.133333l19.285333 6.101334 7.466667 18.773333c20.010667 50.218667 23.424 96.469333 16.128 136.96C875.434667 296.32 896 352.597333 896 416.512c0 53.888-3.84 94.378667-14.933333 133.802667l-11.733334 32.170666c-30.677333 69.333333-98.304 112.64-202.538666 133.248 10.837333 15.018667 15.872 30.250667 15.872 52.394667v42.666667l-0.042667 42.666666a13.013333 13.013333 0 0 0 0.341333 2.730667L682.666667 938.794667c-36.352 0-63.36-17.706667-76.672-45.653334a88.277333 88.277333 0 0 1-8.661334-40.277333v-84.736c0-3.584-0.128-3.797333-8.832-12.501333-23.296-23.296-33.834667-40.874667-33.834666-72.832v-38.613334l38.4-3.84c114.346667-11.52 176.512-43.221333 197.12-89.6l9.6-26.325333c7.68-27.562667 10.88-61.098667 10.88-107.946667 0-49.706667-17.365333-90.837333-50.218667-123.648L742.4 274.773333l7.381333-24.448c6.528-21.717333 8.106667-47.402667 1.152-76.714666a158.634667 158.634667 0 0 0-3.584 0.938666c-22.826667 6.4-51.370667 20.053333-85.76 43.008l-15.658666 10.453334-18.304-4.522667a467.754667 467.754667 0 0 0-111.829334-13.269333c-42.709333 0-84.906667 5.418667-123.946666 16.042666l-19.029334 5.205334-16.256-11.136c-35.541333-24.32-65.109333-38.826667-88.746666-45.568a158.293333 158.293333 0 0 0-4.864-1.28c-8.234667 33.92-4.992 61.781333 3.413333 82.688l9.984 25.088-18.346667 19.797333C228.693333 332.629333 213.333333 370.986667 213.333333 416.512c0 41.685333 4.864 76.202667 13.824 102.229333l11.178667 26.453334c27.904 52.352 87.168 83.84 192.853333 95.146666l38.144 4.096v38.357334c0 32-10.538667 49.536-33.834666 72.832-8.704 8.704-8.832 8.96-8.832 12.501333l-0.725334 7.893333c-0.512 2.56-0.512 9.258667 0.170667 37.205334 0.298667 12.8 0.469333 22.997333 0.554667 33.621333a33.962667 33.962667 0 0 1 0.725333 6.656z" p-id="7468"></path></svg></a>
            &nbsp;
            <a href="mailto:x@outlook.com" style=" border-bottom-width: 0px"><svg t="1623645825851" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="9475"width=".9em" height=".9em" fill=#8a8a8a><path d="M426.666667 955.733333H170.666667c-64.034133 0-100.386133-34.048-102.4-95.880533V511.146667c0-33.1264 9.233067-58.794667 27.409066-76.305067L153.6 376.9344V256a17.066667 17.066667 0 0 1 17.066667-17.066667h164.4544l165.666133-165.666133a17.0496 17.0496 0 0 1 24.132267 0L690.5856 238.933333H853.333333a17.066667 17.066667 0 0 1 17.066667 17.066667v120.081067l59.8528 59.8528c16.913067 16.913067 25.480533 42.222933 25.480533 75.2128v348.16c-1.9968 61.713067-38.007467 95.761067-101.358933 96.426666H426.666667z m41.198933-34.133333H854.186667c45.175467-0.4608 66.030933-19.848533 67.4304-62.856533L921.6 511.146667c0-14.660267-2.013867-26.845867-5.9904-36.437334l-50.210133 50.210134-0.0512 0.0512-340.445867 339.592533-0.034133 0.034133-57.002667 57.002667zM109.550933 473.326933C104.789333 483.345067 102.4 495.9744 102.4 511.146667v348.16C103.799467 902.212267 124.842667 921.6 170.666667 921.6h248.9344l69.12-69.12L109.550933 473.326933zM187.733333 503.227733l325.137067 325.137067L836.266667 505.770667V273.066667H187.733333v230.161066z m682.666667-78.882133v47.291733l23.6544-23.6544L870.4 424.3456zM131.652267 447.146667L153.6 469.0944v-43.895467L131.652267 447.146667zM383.3856 238.933333h258.935467L512.853333 109.4656 383.3856 238.933333zM597.333333 614.4H426.666667a17.066667 17.066667 0 1 1 0-34.133333h170.666666a17.066667 17.066667 0 1 1 0 34.133333z m85.333334-85.333333H341.333333a17.066667 17.066667 0 1 1 0-34.133334h341.333334a17.066667 17.066667 0 1 1 0 34.133334z m0-85.333334H341.333333a17.066667 17.066667 0 0 1 0-34.133333h341.333334a17.066667 17.066667 0 1 1 0 34.133333z" p-id="9476"></path></svg></a>
            &nbsp;
            <a href="//x.com/xxxcg" style=" border-bottom-width: 0px"> <svg t="1623645867604" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="10970"width=".9em" height=".9em" fill=#8a8a8a><path d="M854.613333 187.221333a39.338667 39.338667 0 0 0 13.226667-7.552 42.581333 42.581333 0 0 1 60.16 4.053334c15.530667 17.792 13.696 44.8-4.053333 60.330666a124.330667 124.330667 0 0 1-41.344 23.936c-25.6 8.917333-51.456 9.685333-75.434667 5.888a121.770667 121.770667 0 0 1-12.117333-2.474666 42.666667 42.666667 0 0 1-22.186667-14.464c-35.242667-43.776-76.928-54.186667-135.253333-32.725334-54.741333 20.181333-76.586667 65.450667-66.261334 149.248 3.157333 25.6-16.853333 48.128-42.581333 48-137.173333-0.853333-262.912-61.610667-375.594667-180.053333a42.837333 42.837333 0 0 1 1.408-60.501333 42.581333 42.581333 0 0 1 60.330667 1.450666c84.224 88.576 173.525333 138.24 268.8 150.528 1.408-93.184 43.050667-158.890667 124.416-188.928 86.186667-31.786667 162.346667-16 219.946667 46.293334 9.088 0.64 18.432-0.213333 26.538666-3.029334zM360.192 810.496c157.866667 0 298.112-67.328 389.973333-220.714667 33.706667-56.192 52.565333-121.386667 56.576-196.266666a42.666667 42.666667 0 1 1 85.205334 4.565333c-4.736 88.405333-27.562667 167.210667-68.608 235.733333C714.794667 815.061333 546.090667 896 360.192 896c-97.834667 0-184.106667-26.922667-257.408-80.810667-34.944-25.6-13.909333-81.066667 29.184-77.056 62.421333 5.888 134.442667-15.104 216.192-64.682666a42.624 42.624 0 0 1 58.581333 14.464c12.202667 20.224 5.76 46.506667-14.421333 58.709333-39.424 23.893333-77.738667 42.410667-114.901333 55.381333a390.613333 390.613333 0 0 0 82.773333 8.490667zM136.405333 371.541333A42.624 42.624 0 1 1 215.04 338.346667c9.301333 22.186667 24.234667 38.229333 46.08 49.408 20.992 10.709333 29.312 36.48 18.645333 57.514666a42.624 42.624 0 0 1-57.386666 18.645334 179.626667 179.626667 0 0 1-85.973334-92.416z m39.253334 170.026667a42.794667 42.794667 0 0 1 15.018666-58.581333 42.624 42.624 0 0 1 58.453334 15.018666c16.768 28.373333 33.664 42.922667 50.261333 46.805334a42.752 42.752 0 0 1-19.2 83.285333c-42.069333-9.728-76.8-39.594667-104.533333-86.528z" p-id="10971"></path></svg></a>
            &nbsp;
            <a href="//bangumi.tv/user/xxx" style=" border-bottom-width: 0px"><svg t="1611399107225" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2100" width=".9em" height=".9em" fill=#8a8a8a><path d="M228.115268 615.399298a12.300795 12.300795 0 0 0 11.35458 7.569719 12.471113 12.471113 0 0 0 4.749999-0.965139l147.609537-61.882459a12.300795 12.300795 0 0 0 0.26494-22.557765l-147.609537-66.235049a12.300795 12.300795 0 1 0-10.067727 22.444219l121.740019 54.634453-121.456155 50.906366a12.300795 12.300795 0 0 0-6.585656 16.085655zM399.020617 627.965033H239.469848a12.300795 12.300795 0 0 0 0 24.601589h159.550769a12.300795 12.300795 0 0 0 0-24.601589zM399.020617 667.460046H239.469848a12.300795 12.300795 0 0 0 0 24.601589h159.550769a12.300795 12.300795 0 0 0 0-24.601589zM872.941851 476.892349l-133.283841 58.381464a12.300795 12.300795 0 0 0-0.397411 22.349598l133.302766 64.058754a12.073703 12.073703 0 0 0 5.317729 1.23008 12.300795 12.300795 0 0 0 5.336652-23.390435l-109.15536-52.42031L882.896033 499.469038a12.300795 12.300795 0 1 0-9.954182-22.576689zM877.881094 627.965033h-148.101569a12.300795 12.300795 0 0 0 0 24.601589h148.101569a12.300795 12.300795 0 0 0 0-24.601589zM877.881094 667.460046h-148.101569a12.300795 12.300795 0 0 0 0 24.601589h148.101569a12.300795 12.300795 0 0 0 0-24.601589zM644.866193 537.128395h-162.919295a12.28187 12.28187 0 0 0-10.711153 18.318722l81.374488 145.130453a12.300795 12.300795 0 0 0 21.460155 0l81.374489-145.130453a12.300795 12.300795 0 0 0-10.730078-18.318722z m-81.374488 132.299778l-60.444213-107.698189h120.888426z" p-id="2101"></path><path d="M891.411968 334.960102H648.405037c-6.812748-15.13944-19.813742-28.386449-36.864535-38.018917L803.092262 19.283861a12.300795 12.300795 0 0 0-20.249001-13.966133L588.566402 286.873457a147.723082 147.723082 0 0 0-45.418319-7.001991 151.507942 151.507942 0 0 0-31.887445 3.368526L239.980804 4.712151A12.300795 12.300795 0 0 0 222.437978 21.87649l262.726051 269.803739c-22.14143 9.821711-39.116527 25.112546-47.310749 43.242025H132.547555A91.763929 91.763929 0 0 0 40.764702 426.705107v414.44216A91.763929 91.763929 0 0 0 132.547555 932.967969h268.024855l-19.908363 46.989036c-12.641432 29.881469 22.614538 57.094612 48.294812 37.299794L538.473781 932.967969h352.938187a91.763929 91.763929 0 0 0 91.782853-91.782853v-414.442161a91.763929 91.763929 0 0 0-91.782853-91.782853z m34.839635 463.815658a60.709153 60.709153 0 0 1-60.709153 60.709153H585.670984L487.870204 932.967969l-77.002975 57.851583 24.412346-57.851583 31.016927-73.483056H198.082405A60.728077 60.728077 0 0 1 137.27863 798.737912V440.330602a60.728077 60.728077 0 0 1 60.728077-60.728077h667.460046a60.709153 60.709153 0 0 1 60.709153 60.728077z" p-id="2102"></path></svg></a>
            &nbsp;
            <a href="//xxx" style=" border-bottom-width: 0px"><svg t="1623645993260" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="14230" width=".9em" height=".9em" fill=#8a8a8a><path d="M834.24 127.872a95.168 95.168 0 0 0-29.856 7.136h-0.128c-9.12 3.616-52.48 21.856-118.4 49.504l-236.224 99.488c-169.504 71.36-336.128 141.632-336.128 141.632l1.984-0.768s-11.488 3.776-23.488 12a64.96 64.96 0 0 0-18.752 18.144c-5.888 8.64-10.624 21.856-8.864 35.52 2.88 23.104 17.856 36.96 28.608 44.608 10.88 7.744 21.248 11.36 21.248 11.36h0.256l156.256 52.64c7.008 22.496 47.616 156 57.376 186.752 5.76 18.368 11.36 29.856 18.368 38.624 3.392 4.48 7.36 8.224 12.128 11.232a35.808 35.808 0 0 0 7.872 3.392l-1.6-0.384c0.48 0.128 0.864 0.512 1.216 0.64 1.28 0.352 2.144 0.48 3.776 0.736 24.736 7.488 44.608-7.872 44.608-7.872l1.12-0.896 92.256-84 154.624 118.624 3.52 1.504c32.224 14.144 64.864 6.272 82.112-7.616 17.376-13.984 24.128-31.872 24.128-31.872l1.12-2.88 119.488-612.128c3.392-15.104 4.256-29.248 0.512-42.976a57.824 57.824 0 0 0-24.992-33.504 59.904 59.904 0 0 0-34.144-8.64z m-3.232 65.6c-0.128 2.016 0.256 1.792-0.64 5.664v0.352l-118.368 605.76c-0.512 0.864-1.376 2.752-3.744 4.64-2.496 1.984-4.48 3.232-14.88-0.896l-189.12-144.992-114.24 104.128 24-153.28 308.992-288c12.736-11.84 8.48-14.336 8.48-14.336 0.896-14.528-19.232-4.256-19.232-4.256l-389.632 241.376-0.128-0.64-186.752-62.88v-0.128l-0.48-0.096a8.64 8.64 0 0 0 0.96-0.384l1.024-0.512 0.992-0.352s166.752-70.272 336.256-141.632c84.864-35.744 170.368-71.744 236.128-99.52 65.76-27.616 114.368-47.872 117.12-48.96 2.624-1.024 1.376-1.024 3.264-1.024z" p-id="14231"></path></svg></a><br/>
            Copyright &copy; 2019 - 2021 &nbsp;<span><a href="x.com">bGZoCg</a></span>&nbsp;. All rights reserved. Articles and comments are copyright their respective authors, submission implies license to publish on this web site. The whole blog runs with <span><a href="https://pages.github.com/">Github Page</a></span>, <span><a href="jsdelivr">Jsdelivr CDN</a></span> and <span><a href="https://aliyun.com">Aliyun</a></span> Oss, which build by <span><a href="https://gohugo.io/">Hugo</a></span>, <span><a href="https://github.com/ianrodrigues/hugo-tailwind-journal/">hugo-tailwind-journal</a></span> and font from <span><a href="https://3type.cn/fonts/dinkie_bitmap/">3type-DinkieBitmap</a></span>. The code is under<span><a rel="license" href="http://www.opensource.org/licenses/bsd-license.php">BSD licensed</a>, articles are licensed under a <span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"> BY_NC Creative Commons Attribution 4.0 Generic License</a></span>.
            </p>
        </footer>
    </div>
    
</body>
</html>